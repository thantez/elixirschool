---
version: 1.2.5
title: مجموعه‌ها
---

لیست‌ها، توپل‌ها، لیست‌های کلیددار و مپ ها.

{% include toc.html %}

## لیست‌ها

لیست‌ها مجموعه‌های ساده‌ای از مقادیری هستند که میتوانند انواع مختلفی داشته باشند؛ همچنین، این مقادیر لزوما یکتا نیستند (دارای مقادیر تکراری):

```elixir
iex> [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
```

پیاده‌سازی مجموعه‌های لیست در الیکسیر به صورت لیست های پیوندی (linked lists) است. این بدان معناست که فرایند یافتن طول لیست و دست‌یابی به آن با مرتبه خطی (`O(n)`) انجام می‌شود. به همین دلیل، اضافه کردن یک عنصر به ابتدای لیست سریع‌تر از اضافه کردن عنصر به انتهای آن است:

```elixir
iex> list = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
# Prepending (fast)
iex> ["π"] ++ list
["π", 3.14, :pie, "Apple"]
# Appending (slow)
iex> list ++ ["Cherry"]
[3.14, :pie, "Apple", "Cherry"]
```

### پیونددهی لیست

پیونددهی لیست با عملگر `++/2` (ابتدا ++ ذکر می‌شود و بعد از اسلش، عدد ۲ ذکر می‌شود، در فرمت راست به چپ این نشانه‌گذاری ممکن است اشتباه نوشته شود) انجام می‌شود:

```elixir
iex> [1, 2] ++ [3, 4, 1]
[1, 2, 3, 4, 1]
```

نکته‌ی حاشیه‌ای در مورد قالب استفاده شده در مورد نام عملگر مورد استفاده در بالا (`++/2`) این است که:
در الیکسیر (و ارلنگ، که الیکسیر برمبنای آن ساخته شده)، نام یک تابع یا عملگر دارای دو جزء است؛ نامی که به آن می‌دهید (در اینجا `++`) و _اریتی_ آن. اریتی (Arity) یک قسمت اصلی و مرکزی در مباحث مربوط به کد الیکسیر (و ارلنگ) است؛ نشانگر تعداد آرگومان‌هاییست که یک تابع میگیرد (یعنی همان عدد 2 در این قسمت). اریتی و نام گرفته شده با یک اسلش (خط مورب یا همان علامت /) با هم ترکیب می‌شوند. ما در این مورد، بعدا بیشتر صحبت خواهیم کرد؛ همینقدر اطلاعات به شما کمک میکند که نشانه‌گذاری (notation) انجام شده را درک کنید.

### تفاضل لیست

پشتیبانی از تفاضل لیست، با عملگر `--/2` انجام می‌شود؛ این عملگر در مقابل تفاضل مقادیر فراموش شده در لیست، ایمن است (یعنی اگر مقداری در لیست دوم باشد که در لیست اول نیست و لیست دوم از لیست اول کم شود، اروری برگردانده نمی‌شود):

```elixir
iex> ["foo", :bar, 42] -- [42, "bar"]
["foo", :bar]
```

مراقب مقادیر تکراری باشید! برای هر عنصر در سمت راست، اولین عنصری که با آن در سمت چپ مطابق باشد، حذف می‌شود (حذف شدن نظیر به نظیر صورت می‌گیرد):

```elixir
iex> [1,2,2,3,2,3] -- [1,2,3,2]
[2, 3]
```

**نکته:** تفاضل لیست از [مقایسه سختگیرانه](../basics/#comparison) برای مطابقت دادن دو عنصر استفاده میکند، مثلا:

```elixir
iex> [2] -- [2.0]
[2]
iex> [2.0] -- [2.0]
[]
```

### سر / دُم (Head / Tail)

وقتی از لیست‌ها استفاده می‌کنیم، این امر متداولیست که از سر و دم استفاده کنیم.
سر، یعنی اولین عنصر لیست و باقی عناصر داخل لیست، دم نامیده‌ می‌شوند.
الیکسیر دو تابع مفید `hd` و `tl` را برای کار با این قسمت‌ها فراهم کرده است:

```elixir
iex> hd [3.14, :pie, "Apple"]
3.14
iex> tl [3.14, :pie, "Apple"]
[:pie, "Apple"]
```


غیر از توابعی که گفته شد، شما می‌توانید از [تطابق الگو](../pattern-matching/) و عملگر `|` برای جداسازی یک لیست به سر و دم، استفاده کنید.ما در مورد این الگو در آینده صحبت خواهیم کرد.

```elixir
iex> [head | tail] = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
iex> head
3.14
iex> tail
[:pie, "Apple"]
```

## توپل‌ها

توپل‌ها شبیه لیست ها هستند؛ اما با این تفاوت که به صورت پیوسته در حافظه ذخیره می‌شوند.
این باعث می‌شود که دسترسی به طول آنها و محاسبه طول آنها، سریع باشد؛ اما تغییر در آنها گران تمام شود. یک توپل جدید باید به صورت کامل در حافظه ذخیره یا رونوشت (کپی) شود. توپل ها درون علامت دو ابرو (آکولاد یا همان علامت { و }) تعریف می‌شوند.

```elixir
iex> {3.14, :pie, "Apple"}
{3.14, :pie, "Apple"}
```

یک مکانیزم معمولی برای برگرداندن چندین مقدار از یک تابع، استفاده از توپل ها به عنوان خروجیست؛ فایده این کار در قسمت [تطابق الگو](../pattern-matching/) مشخص می‌شود:

```elixir
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

## لیست‌های کلیددار (Keyword lists)

لیست‌های کلید دار و مپ‌ها،‌ مجموعه‌هایی وابسته در الیکسیر هستند.
در الیکسیر، یک لیست کلیددار، لیستی ویژه از دو عنصری های توپل شده است که اولین عضو آنها حتما یک اتم است. لیست‌های کلیددار از نظر کارایی (performance)، مشابه لیست‌ها هستند.

```elixir
iex> [foo: "bar", hello: "world"]
[foo: "bar", hello: "world"]
iex> [{:foo, "bar"}, {:hello, "world"}]
[foo: "bar", hello: "world"]
```

پس، سه چیزی که باعث متمایز شدن لیست‌های کلیددار می‌شوند و عملا مشخصه‌ی آنها حساب می‌شوند، موارد زیر است:

+ کلیدها اتم هستند.
+ کلیدها مرتب شده هستند.
+ کلیدها لزوما یکتا نیستند.

به همین دلایل، لیست‌های کلیددار به طور متداول برای ارسال کردن ویژگی‌ها (آپشن‌ها) به توابع، استفاده می‌شوند.

## مپ‌ها

در الیکسییر، مپ‌ها فضای ذخیره سازی کلید-مقداری "go-to" هستند.
(maps are the "go-to" key-value store)

برخلاف لیست‌های کلیددار، مپ‌ها کلیدهایی از هر نوعی را می‌پذیرند و بدون ترتیبند. شما می‌توانید یک مپ را با نحو (سینتکس) `%{}` تعریف کنید:

```elixir
iex> map = %{:foo => "bar", "hello" => :world}
%{:foo => "bar", "hello" => :world}
iex> map[:foo]
"bar"
iex> map["hello"]
:world
```

پس از الیکسیر ۱٫۲، متغیرها نیز به عنوان کلید های مپ قابل استفاده شدند:

```elixir
iex> key = "hello"
"hello"
iex> %{key => "world"}
%{"hello" => "world"}
```

اگر چیزی تکراری در مپ وارد شود، مقدار قبلی جایگزین می‌شود (مقدار جدید جای مقدار قبلی را می‌گیرد):

```elixir
iex> %{:foo => "bar", :foo => "hello world"}
%{foo: "hello world"}
```

همانطور که در خروجی بالا مشخص شده، در اینجا یک نحو (سینتکس) خاص برای مپ‌هایی وجود دارد که فقط شامل کلیدهایی از جنس اتم هستند:

```elixir
iex> %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
true
```

به علاوه، نحو ویژه‌ای هم برای دستیابی به کلیدهای وجود دارد:

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> map.hello
"world"
```

یکی دیگر از ویژگی های جذاب مپ‌ها اینست که آنها نحو (سینتکس) ویژه خودشان را برای به روز شد (آپدیت شدن) در اختیار دارند:

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> %{map | foo: "baz"}
%{foo: "baz", hello: "world"}
```
